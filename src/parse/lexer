/*
    Compiler - a test of flexc++/bisonc++ for a small programming language.
    Copyright (C) 2014 - 2015  G. Endignoux

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see http://www.gnu.org/licenses/gpl-3.0.txt
*/

%x COMMENT
%x CHAR
%x STRING
%x NEWLINE

%%


// ******************** Keywords ********************
// Classes
class {
    *d_val = matched();
    std::cerr << "lexer: CLASS" << std::endl;
    return Parser::CLASS; }
concept {
    *d_val = matched();
    std::cerr << "lexer: CONCEPT" << std::endl;
    return Parser::CONCEPT; }
def {
    *d_val = matched();
    std::cerr << "lexer: DEF" << std::endl;
    return Parser::DEF; }

// Flow control
return {
    *d_val = matched();
    std::cerr << "lexer: RETURN" << std::endl;
    return Parser::RETURN; }
break {
    *d_val = matched();
    std::cerr << "lexer: BREAK" << std::endl;
    return Parser::BREAK; }
continue {
    *d_val = matched();
    std::cerr << "lexer: CONTINUE" << std::endl;
    return Parser::CONTINUE; }
pass {
    *d_val = matched();
    std::cerr << "lexer: PASS" << std::endl;
    return Parser::PASS; }

// Loops
forever {
    *d_val = matched();
    std::cerr << "lexer: FOREVER" << std::endl;
    return Parser::FOREVER; }
while {
    *d_val = matched();
    std::cerr << "lexer: WHILE" << std::endl;
    return Parser::WHILE; }
for {
    *d_val = matched();
    std::cerr << "lexer: FOR" << std::endl;
    return Parser::FOR; }
in {
    *d_val = matched();
    std::cerr << "lexer: IN" << std::endl;
    return Parser::IN; }

// Conditions
if {
    *d_val = matched();
    std::cerr << "lexer: IF" << std::endl;
    return Parser::IF; }
elif {
    *d_val = matched();
    std::cerr << "lexer: ELIF" << std::endl;
    return Parser::ELIF; }
else {
    *d_val = matched();
    std::cerr << "lexer: ELSE" << std::endl;
    return Parser::ELSE; }
switch {
    *d_val = matched();
    std::cerr << "lexer: SWITCH" << std::endl;
    return Parser::SWITCH; }
case {
    *d_val = matched();
    std::cerr << "lexer: CASE" << std::endl;
    return Parser::CASE; }

// Filtering
match {
    *d_val = matched();
    std::cerr << "lexer: MATCH" << std::endl;
    return Parser::MATCH; }
with {
    *d_val = matched();
    std::cerr << "lexer: WITH" << std::endl;
    return Parser::WITH; }
as {
    *d_val = matched();
    std::cerr << "lexer: AS" << std::endl;
    return Parser::AS; }
default {
    *d_val = matched();
    std::cerr << "lexer: DEFAULT" << std::endl;
    return Parser::DEFAULT; }


// ******************** Basic data ********************
[A-Za-z_][A-Za-z0-9_]* {
    *d_val = matched();
    std::cerr << "lexer: IDENTIFIER" << std::endl;
    return Parser::IDENTIFIER; }
0x[0-9A-Fa-f]+ {
    *d_val = matched();
    std::cerr << "lexer: NUMBER" << std::endl;
    return Parser::NUMBER; }
0b[01]+ {
    *d_val = matched();
    std::cerr << "lexer: NUMBER" << std::endl;
    return Parser::NUMBER; }
[+-]?[0-9]*\.[0-9]+e[+-]?[0-9]+ {
    *d_val = matched();
    std::cerr << "lexer: NUMBER" << std::endl;
    return Parser::NUMBER; }
[+-]?[0-9]+(\.[0-9]*)?e[+-]?[0-9]+ {
    *d_val = matched();
    std::cerr << "lexer: NUMBER" << std::endl;
    return Parser::NUMBER; }
[+-]?[0-9]*\.[0-9]+ {
    *d_val = matched();
    std::cerr << "lexer: NUMBER" << std::endl;
    return Parser::NUMBER; }
[+-]?[0-9]+(\.[0-9]*)? {
    *d_val = matched();
    std::cerr << "lexer: NUMBER" << std::endl;
    return Parser::NUMBER; }


// ******************** Operators ********************
"(" {
    *d_val = matched();
    std::cerr << "lexer: LEFT_PAR" << std::endl;
    return Parser::LEFT_PAR; }
")" {
    *d_val = matched();
    std::cerr << "lexer: RIGHT_PAR" << std::endl;
    return Parser::RIGHT_PAR; }
"[" {
    *d_val = matched();
    std::cerr << "lexer: LEFT_BRACKET" << std::endl;
    return Parser::LEFT_BRACKET; }
"]" {
    *d_val = matched();
    std::cerr << "lexer: RIGHT_BRACKET" << std::endl;
    return Parser::RIGHT_BRACKET; }
"," {
    *d_val = matched();
    std::cerr << "lexer: COMMA" << std::endl;
    return Parser::COMMA; }
".." {
    *d_val = matched();
    std::cerr << "lexer: RANGE" << std::endl;
    return Parser::RANGE; }
"." {
    *d_val = matched();
    std::cerr << "lexer: DOT" << std::endl;
    return Parser::DOT; }

"**="|"+="|"-="|"*="|"/="|"%="|"<<="|">>="|"^="|"|="|"&="|":=" {
    *d_val = matched();
    std::cerr << "lexer: OP_ASSIGN" << std::endl;
    return Parser::OP_ASSIGN; }
"||" {
    *d_val = matched();
    std::cerr << "lexer: COND_OR" << std::endl;
    return Parser::COND_OR; }
"&&" {
    *d_val = matched();
    std::cerr << "lexer: COND_AND" << std::endl;
    return Parser::COND_AND; }

"**" {
    *d_val = matched();
    std::cerr << "lexer: POW" << std::endl;
    return Parser::POW; }
"++"|"--" {
    *d_val = matched();
    std::cerr << "lexer: OP_UNARY" << std::endl;
        return Parser::OP_UNARY; }
"*"|"/"|"%" {
    *d_val = matched();
    std::cerr << "lexer: OP_FACTOR" << std::endl;
    return Parser::OP_FACTOR; }
"+"|"-" {
    *d_val = matched();
    std::cerr << "lexer: OP_TERM" << std::endl;
    return Parser::OP_TERM; }
"<<"|">>" {
    *d_val = matched();
    std::cerr << "lexer: OP_SHIFT" << std::endl;
    return Parser::OP_SHIFT; }
"&" {
    *d_val = matched();
    std::cerr << "lexer: AND" << std::endl;
    return Parser::AND; }
"^" {
    *d_val = matched();
    std::cerr << "lexer: XOR" << std::endl;
    return Parser::XOR; }
"|" {
    *d_val = matched();
    std::cerr << "lexer: OR" << std::endl;
    return Parser::OR; }

"<="|">="|"!="|"<"|">"|"==" {
    *d_val = matched();
    std::cerr << "lexer: OP_COMPARE" << std::endl;
    return Parser::OP_COMPARE; }
"~"|"!" {
    *d_val = matched();
    std::cerr << "lexer: OP_UNARY" << std::endl;
    return Parser::OP_UNARY; }


// ******************** Comment ********************
\/\/.*$ {
    std::cerr << "\tlexer: ignoring line-comment" << std::endl;
    //return Parser::COMMENT;
}

\/\* {
    more();
    begin(StartCondition__::COMMENT);
}
<COMMENT> {
    \*\/ {
        begin(StartCondition__::INITIAL);
        std::cerr << "\tlexer: ignoring multi-comment" << std::endl;
        //return Parser::COMMENT;
    }
    
    .|\n {
        more();
    }
}


// ******************** Char ********************
\' {
    more();
    begin(StartCondition__::CHAR);
}
<CHAR> {
    \' {
        begin(StartCondition__::INITIAL);
        *d_val = matched();
        std::cerr << "lexer: CHAR" << std::endl;
        return Parser::CHAR;
    }
    
    \\.|. {
        more();
    }
    
    \n {
        *d_val = matched();
        std::cerr << "lexer: ERR_CHAR" << std::endl;
        return Parser::ERR_CHAR;
    }
}


// ******************** String ********************
\" {
    more();
    begin(StartCondition__::STRING);
}
<STRING> {
    \" {
        begin(StartCondition__::INITIAL);
        *d_val = matched();
        std::cerr << "lexer: STRING" << std::endl;
        return Parser::STRING;
    }
    
    \\.|. {
        more();
    }
    
    \n {
        *d_val = matched();
        std::cerr << "lexer: ERR_STRING" << std::endl;
        return Parser::ERR_STRING;
    }
}


// ******************** Indentation ********************
<NEWLINE>^[ \t]*/\n {
    begin(StartCondition__::INITIAL);
    std::cerr << "\tlexer: empty line..." << std::endl;
}

<NEWLINE>^[ \t]*\/\/ {
    begin(StartCondition__::INITIAL);
    std::cerr << "\tlexer: empty line before comment..." << std::endl;
    push('/');
    push('/');
}

<NEWLINE>^[ \t]*\/\* {
    begin(StartCondition__::INITIAL);
    std::cerr << "\tlexer: empty line before comment..." << std::endl;
    push('*');
    push('/');
}

<NEWLINE>^[ \t]*/[^ \t\n] {
    begin(StartCondition__::INITIAL);
    std::cerr << "\tlexer: checking indent..." << std::endl;

    unsigned int indent = 0;
    for (unsigned int i = 0 ; i < length() ; ++i)
        if (matched()[i] == ' ')
            ++indent;
        else
            indent = (indent + 4) & (~3);

    std::cerr << "\tlexer: indent = " << indent << std::endl;

    if (mIndentLevels.empty())
    {
        std::cerr << "\tlexer: no previous indent" << std::endl;
        if (indent > 0)
        {
            mIndentLevels.push(indent);
            std::cerr << "lexer: INDENT" << std::endl;
            return Parser::INDENT;
        }
    }
    else if (indent > mIndentLevels.top())
    {
        std::cerr << "\tlexer: previous indent = " << mIndentLevels.top() << std::endl;
        mIndentLevels.push(indent);
        std::cerr << "lexer: INDENT" << std::endl;
        return Parser::INDENT;
    }
    else if (indent < mIndentLevels.top())
    {
        std::cerr << "\tlexer: previous indent = " << mIndentLevels.top() << std::endl;
        mIndentLevels.pop();
        unsigned int last = mIndentLevels.empty() ? 0 : mIndentLevels.top();
        std::cerr << "\tlexer: last indent = " << last << std::endl;

        if (indent > last) {
            std::cerr << "lexer: ERR_INDENT" << std::endl;
            return Parser::ERR_INDENT;
        }
        if (indent <= last)
        {
            for (unsigned int i = 0 ; i < indent ; ++i)
                push(' ');
        }
        push('\n');

        std::cerr << "lexer: DEDENT" << std::endl;
        return Parser::DEDENT;
    }
}

<NEWLINE><<EOF>> {
    begin(StartCondition__::INITIAL);
    std::cerr << "\tlexer: checking EOF..." << std::endl;
    if (!mIndentLevels.empty())
    {
        mIndentLevels.pop();

        if (!mIndentLevels.empty())
        {
            unsigned int indent = mIndentLevels.top();
            for (unsigned int i = 0 ; i < indent ; ++i)
                push(' ');
        }
        push('\n');

        std::cerr << "lexer: DEDENT" << std::endl;
        return Parser::DEDENT;
    }
    else
    {
        std::cerr << "lexer: EOF" << std::endl;
        leave(0);
    }
}

<<EOF>> {
    push('\n');
}


// ******************** Spaces ********************
[ \t]+ {
    std::cerr << "\tlexer: ignoring spaces" << std::endl; }
\n {
    begin(StartCondition__::NEWLINE);
    std::cerr << "lexer: EOL" << std::endl;
    return Parser::EOL; }


// Unknown
. {
    *d_val = matched();
    std::cerr << "lexer: UNKNOWN_CHAR" << std::endl;
    return Parser::UNKNOWN_CHAR; }

