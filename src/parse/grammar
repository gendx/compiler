/*
    Compiler - a test of flexc++/bisonc++ for a small programming language.
    Copyright (C) 2014 - 2015  G. Endignoux

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see http://www.gnu.org/licenses/gpl-3.0.txt
*/

%scanner                Scanner.h
%scanner-token-function d_scanner.lex()

//%debug
%error-verbose

%baseclass-preinclude ParserPreinclude.h

%polymorphic
    EXP: std::shared_ptr<Expression>;
    EXPLIST: std::shared_ptr<ExprList>;
    IDENT: std::shared_ptr<Identifier>;
    CALL: std::shared_ptr<Call>;
    SIGNATURE: std::shared_ptr<Signature>;
    STMT: std::shared_ptr<Statement>;
    BLOCK: std::shared_ptr<Block>;
    IF: std::shared_ptr<If>;
    SWITCH: std::shared_ptr<Switch>;
    MATCH: std::shared_ptr<Match>;
    STR: std::string;

%type <EXP> expr number char string
%type <EXPLIST> anylist list
%type <IDENT> identifier
%type <CALL> call
%type <SIGNATURE> signature
%type <STMT> startrule stmt
%type <BLOCK> stmts indented
%type <IF> elsestmts
%type <SWITCH> casestmts
%type <MATCH> withstmts
%type <STR> dedent anyeols eols

// lowest precedence first, highest precedence last
%token <STR> IDENTIFIER NUMBER CHAR STRING
%token <STR> EOL INDENT DEDENT
%token <STR> ERR_CHAR ERR_STRING ERR_INDENT UNKNOWN_CHAR
%token <STR> CLASS CONCEPT DEF
%token <STR> RETURN BREAK CONTINUE PASS
%token <STR> FOREVER WHILE FOR IN
%token <STR> IF ELSE ELIF SWITCH CASE MATCH WITH AS DEFAULT
%right <STR> OP_ASSIGN
%left <STR> RANGE
%left <STR> COND_OR
%left <STR> COND_AND
%left <STR> OP_COMPARE
%left <STR> OR
%left <STR> XOR
%left <STR> AND
%left <STR> OP_SHIFT
%left <STR> OP_TERM
%left <STR> OP_FACTOR
%right <STR> OP_UNARY
%right <STR> POW
%left <STR> LEFT_PAR RIGHT_PAR LEFT_BRACKET RIGHT_BRACKET COMMA DOT


%%

startrule:
    stmts {
        $1->reverse();
        $$ = $1;
        mAst = AST($1);
    }
;

stmts:
    anyeols {
        $$ = std::make_shared<Block>();
    }
|   anyeols stmt stmts {
        $$ = $3;
        $$->append($2);
    }
;

stmt:
    expr EOL {
        $$ = std::make_shared<ExprStmt>($1);
    }
|   RETURN expr EOL {
        $$ = std::make_shared<Return>($2);
    }
|   BREAK EOL {
        $$ = std::make_shared<Break>();
    }
|   CONTINUE EOL {
        $$ = std::make_shared<Continue>();
    }
|   PASS EOL {
        $$ = std::make_shared<Pass>();
    }
|   CLASS identifier indented {
        $$ = std::make_shared<Class>($2, $3);
    }
|   CONCEPT identifier indented {
        $$ = std::make_shared<Concept>($2, $3);
    }
|   DEF signature indented {
        $$ = std::make_shared<Function>($2, $3);
    }
|   FOREVER indented {
        $$ = std::make_shared<Forever>($2);
    }
|   WHILE expr indented {
        $$ = std::make_shared<While>($2, $3);
    }
|   FOR expr IN expr indented {
        $$ = std::make_shared<For>($2, $4, $5);
    }
|   IF expr indented elsestmts {
        $4->append($2, $3);
        $4->reverse();
        $$ = $4;
    }
|   SWITCH expr EOL casestmts {
        $4->setExpr($2);
        $4->reverse();
        $$ = $4;
    }
|   MATCH expr EOL withstmts {
        $4->setExpr($2);
        $4->reverse();
        $$ = $4;
    }
;


elsestmts:
    {
        $$ = std::make_shared<If>();
    }
|   ELSE indented {
        $$ = std::make_shared<If>($2);
    }
|   ELIF expr indented elsestmts {
        $$ = $4;
        $$->append($2, $3);
    }
;

casestmts:
    {
        $$ = std::make_shared<Switch>();
    }
|   DEFAULT indented {
        $$ = std::make_shared<Switch>($2);
    }
|   CASE expr indented casestmts {
        $$ = $4;
        $$->append($2, $3);
    }
;

withstmts:
    {
        $$ = std::make_shared<Match>();
    }
|   WITH expr AS identifier indented withstmts {
        $$ = $6;
        $$->append($2, $4, $5);
    }
;


indented:
    eols INDENT stmts dedent {
        $3->reverse();
        $$ = $3;
    }
;

dedent:
    DEDENT EOL
;

anyeols:
|   EOL anyeols
;

eols:
    EOL
|   EOL eols
;


anylist:
    {
        $$ = std::make_shared<ExprList>();
    }
|   list {
        $$ = $1;
    }
;

list:
    list COMMA expr {
        $$ = $1;
        $$->append($3);
    }
|   expr {
        $$ = std::make_shared<ExprList>($1);
    }
;


call:
    identifier LEFT_PAR anylist RIGHT_PAR {
        $$ = std::make_shared<Call>($1, $3);
    }
;

signature:
    expr call {
        $$ = std::make_shared<Signature>($1, $2);
    }
;

expr:
    identifier {
        $$ = $1;
    }
|   number {
        $$ = $1;
    }
|   char {
        $$ = $1;
    }
|   string {
        $$ = $1;
    }
|   call {
        $$ = $1;
    }
|   LEFT_PAR expr RIGHT_PAR {
        $$ = $2;
    }
|   LEFT_PAR error RIGHT_PAR {
        std::cout << "error inside parenthesis" << std::endl;
    }

|   expr DOT identifier {
        $$ = std::make_shared<Member>($1, $3);
    }
|   expr DOT call {
        $$ = std::make_shared<Method>($1, $3);
    }
|   expr LEFT_BRACKET anylist RIGHT_BRACKET {
        $$ = std::make_shared<Index>($1, $3);
    }
|   expr identifier {
        $$ = std::make_shared<Identify>($1, $2);
    }

|   expr OP_ASSIGN expr {
        $$ = std::make_shared<Binary>($1, $2, $3);
    }
|   expr RANGE expr {
        $$ = std::make_shared<Binary>($1, $2, $3);
    }
|   expr COND_OR expr {
        $$ = std::make_shared<Binary>($1, $2, $3);
    }
|   expr COND_AND expr {
        $$ = std::make_shared<Binary>($1, $2, $3);
    }
|   expr OP_COMPARE expr {
        $$ = std::make_shared<Binary>($1, $2, $3);
    }
|   expr OR expr {
        $$ = std::make_shared<Binary>($1, $2, $3);
    }
|   expr XOR expr {
        $$ = std::make_shared<Binary>($1, $2, $3);
    }
|   expr AND expr {
        $$ = std::make_shared<Binary>($1, $2, $3);
    }
|   expr OP_SHIFT expr {
        $$ = std::make_shared<Binary>($1, $2, $3);
    }
|   expr OP_TERM expr {
        $$ = std::make_shared<Binary>($1, $2, $3);
    }
|   expr OP_FACTOR expr {
        $$ = std::make_shared<Binary>($1, $2, $3);
    }
|   expr POW expr {
        $$ = std::make_shared<Binary>($1, $2, $3);
    }
|   OP_UNARY expr {
        $$ = std::make_shared<Unary>($1, $2);
    }
|   OP_TERM expr %prec OP_UNARY {
        $$ = std::make_shared<Unary>($1, $2);
    }
;


identifier:
    IDENTIFIER {
        $$ = std::make_shared<Identifier>(d_scanner.matched());
    }
;
number:
    NUMBER {
        $$ = std::make_shared<DataNumber>(d_scanner.matched());
    }
;
char:
    CHAR {
        $$ = std::make_shared<DataChar>(d_scanner.matched());
    }
;
string:
    STRING {
        $$ = std::make_shared<DataString>(d_scanner.matched());
    }
;
