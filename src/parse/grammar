%scanner                Scanner.h
%scanner-token-function d_scanner.lex()

//%debug
%error-verbose

%stype std::string

// lowest precedence first, highest precedence last
%token IDENTIFIER NUMBER CHAR STRING EOL INDENT DEDENT ERR_CHAR ERR_STRING ERR_INDENT UNKNOWN_CHAR
%token CLASS CONCEPT DEF RETURN
%token FOREVER WHILE FOR IN
%token IF ELSE ELIF SWITCH CASE MATCH WITH AS DEFAULT
%right OP_ASSIGN
%left RANGE
%left COND_OR
%left COND_AND
%left OP_COMPARE
%left OR
%left XOR
%left AND
%left OP_SHIFT
%left OP_TERM
%left OP_FACTOR
%right OP_UNARY
%right POW
%left LEFT_PAR RIGHT_PAR LEFT_BRACKET RIGHT_BRACKET COMMA DOT


%%

startrule:
    stmts {
        $$ = $1;
        std::cout << std::endl << "startrule:" << std::endl << std::endl << $$ << std::endl;
    }
;

stmts:
    anyeols {
        $$ = "";
    }
|   anyeols stmt stmts {
        $$ = $2 + "; " + $3;
    }
;

stmt:
    expr EOL {
        $$ = $1;
        std::cout << "expr: " << $$ << std::endl;
    }
|   RETURN expr EOL {
        $$ = "return(" + $2 + ")";
        std::cout << $$ << std::endl;
    }
|   classdef {
        $$ = $1;
    }
|   function {
        $$ = $1;
    }
|   loop {
        $$ = $1;
    }
|   condition {
        $$ = $1;
    }
;


classdef:
    CLASS identifier indented {
        $$ = "class(" + $2 + ", " + $3 + ")";
        std::cout << $$ << std::endl;
    }
|   CONCEPT identifier indented {
        $$ = "concept(" + $2 + ", " + $3 + ")";
        std::cout << $$ << std::endl;
    }
;

function:
    DEF expr indented {
        $$ = "def(" + $2 + ", " + $3 + ")";
        std::cout << $$ << std::endl;
    }
;

loop:
    FOREVER indented {
        $$ = "forever(" + $2 + ")";
        std::cout << $$ << std::endl;
    }
|   WHILE expr indented {
        $$ = "while(" + $2 + " : " + $3 + ")";
        std::cout << $$ << std::endl;
    }
|   FOR expr IN expr indented {
        $$ = "for(" + $2 + " in " + $4 + " : " + $5 + ")";
        std::cout << $$ << std::endl;
    }
;

condition:
    IF expr indented elsestmts {
        $$ = "if(" + $2 + " : " + $3 + $4 + ")";
        std::cout << $$ << std::endl;
    }
|   SWITCH expr EOL casestmts {
        $$ = "switch(" + $2 + $4 + ")";
        std::cout << $$ << std::endl;
    }
|   MATCH expr EOL withstmts {
        $$ = "match(" + $2 + $4 + ")";
        std::cout << $$ << std::endl;
    }
;

elsestmts:
    {
        $$ = "";
    }
|   ELIF expr indented elsestmts {
        $$ = ", " + $2 + " : " + $3 + $4;
        std::cout << $$ << std::endl;
    }
|   ELSE indented {
        $$ = ", " + $2;
        std::cout << $$ << std::endl;
    }
;

casestmts:
    {
        $$ = "";
    }
|   DEFAULT indented {
        $$ = ", default : " + $2;
        std::cout << "\tcase : " << $$ << std::endl;
    }
|   CASE expr indented casestmts {
        $$ = ", " + $2 + " : " + $3 + $4;
        std::cout << "\tcase : " << $$ << std::endl;
    }
;

withstmts:
    {
        $$ = "";
    }
|   WITH expr AS expr indented withstmts {
        $$ = ", " + $2 + " @ " + $4 + " : " + $5 + $6;
        std::cout << "\twith : " << $$ << std::endl;
    }
;


indented:
    eols INDENT stmts dedent {
        $$ = $3;
        std::cout << "indented : " << $$ << std::endl;
    }
;

dedent:
    DEDENT EOL
;

anyeols:
|   EOL anyeols
;

eols:
    EOL
|   EOL eols
;


anylist:
    {
        $$ = "";
    }
|   list {
        $$ = $1;
        std::cout << "\tlist : " << $$ << std::endl;
    }
;

list:
    list COMMA expr {
        $$ = $1 + ", " + $3;
    }
|   expr {
        $$ = $1;
    }
;


call:
    identifier LEFT_PAR anylist RIGHT_PAR {
        $$ = $1 + $2 + $3 + $4;
        std::cout << "\tcalllist : " << $3 << std::endl;
        std::cout << "\tcall : " << $$ << std::endl;
    }
;

index:
    LEFT_BRACKET anylist RIGHT_BRACKET {
        $$ = $1 + $2 + $3;
        std::cout << "\tbrackets : " << $$ << std::endl;
    }
;

expr:
    data {
        $$ = $1;
        std::cout << "\tdata : " << $$ << std::endl;
    }
|   call {
        $$ = $1;
    }
|   LEFT_PAR expr RIGHT_PAR {
        $$ = $1 + $2 + $3;
        std::cout << "\tparen : " << $$ << std::endl;
    }
|   LEFT_PAR error RIGHT_PAR {
        std::cout << "error inside parenthesis" << std::endl;
    }

|   expr DOT identifier {
        $$ = "(" + $1 + $2 + $3 + ")";
        std::cout << "\tdot : " << $$ << std::endl;
    }
|   expr DOT call {
        $$ = "(" + $1 + $2 + $3 + ")";
        std::cout << "\tdotcall : " << $$ << std::endl;
    }
|   expr call {
        $$ = "(" + $1 + "#" + $2 + ")";
        std::cout << "\tcall : " << $$ << std::endl;
    }
|   expr index {
        $$ = "(" + $1 + $2 + ")";
        std::cout << "\tindex : " << $$ << std::endl;
    }
|   expr identifier {
        $$ = "(" + $1 + "#" + $2 + ")";
        std::cout << "\tconcat : " << $$ << std::endl;
    }

|   expr OP_ASSIGN expr {
        $$ = "(" + $1 + $2 + $3 + ")";
        std::cout << "\tassign : " << $$ << std::endl;
    }
|   expr RANGE expr {
        $$ = "(" + $1 + $2 + $3 + ")";
        std::cout << "\trange : " << $$ << std::endl;
    }
|   expr COND_OR expr {
        $$ = "(" + $1 + $2 + $3 + ")";
        std::cout << "\tcond_or : " << $$ << std::endl;
    }
|   expr COND_AND expr {
        $$ = "(" + $1 + $2 + $3 + ")";
        std::cout << "\tcond_and : " << $$ << std::endl;
    }
|   expr OP_COMPARE expr {
        $$ = "(" + $1 + $2 + $3 + ")";
        std::cout << "\tcompare : " << $$ << std::endl;
    }
|   expr OR expr {
        $$ = "(" + $1 + $2 + $3 + ")";
        std::cout << "\tor : " << $$ << std::endl;
    }
|   expr XOR expr {
        $$ = "(" + $1 + $2 + $3 + ")";
        std::cout << "\txor : " << $$ << std::endl;
    }
|   expr AND expr {
        $$ = "(" + $1 + $2 + $3 + ")";
        std::cout << "\tand : " << $$ << std::endl;
    }
|   expr OP_SHIFT expr {
        $$ = "(" + $1 + $2 + $3 + ")";
        std::cout << "\tshift : " << $$ << std::endl;
    }
|   expr OP_TERM expr {
        $$ = "(" + $1 + $2 + $3 + ")";
        std::cout << "\tterm : " << $$ << std::endl;
    }
|   expr OP_FACTOR expr {
        $$ = "(" + $1 + $2 + $3 + ")";
        std::cout << "\tfactor : " << $$ << std::endl;
    }
|   expr POW expr {
        $$ = "(" + $1 + $2 + $3 + ")";
        std::cout << "\tpow : " << $$ << std::endl;
    }
|   OP_UNARY expr {
        $$ = "(" + $1 + $2 + ")";
        std::cout << "\tunary : " << $$ << std::endl;
    }
|   OP_TERM expr %prec OP_UNARY {
        $$ = "(" + $1 + $2 + ")";
        std::cout << "\tunary : " << $$ << std::endl;
    }
;


data:
    identifier | number | char | string
;

identifier:
    IDENTIFIER {
        $$ = d_scanner.matched();
        std::cout << "ident (" << d_scanner.matched().size() << ") : " << d_scanner.matched() << std::endl;
    }
;
number:
    NUMBER {
        $$ = d_scanner.matched();
        std::cout << "num (" << d_scanner.matched().size() << ") : " << d_scanner.matched() << std::endl;
    }
;
char:
    CHAR {
        $$ = d_scanner.matched();
        std::cout << "char (" << d_scanner.matched().size() << ") : " << d_scanner.matched() << std::endl;
    }
;
string:
    STRING {
        $$ = d_scanner.matched();
        std::cout << "str (" << d_scanner.matched().size() << ") : " << d_scanner.matched() << std::endl;
    }
;
